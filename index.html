<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WebXR 2D→3D POC — v0.5</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    #hud{position:fixed;z-index:3;left:16px;top:16px;display:flex;gap:8px;align-items:center;color:#ddd}
    .pill{background:#303030;border-radius:999px;padding:6px 10px;font-size:12px}
    #status{opacity:.85}
    #bigPlay{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      pointer-events:auto;z-index:4;background:rgba(0,0,0,.35)
    }
    #bigPlay button{
      background:#00a86b;border:none;color:#fff;font-weight:700;font-size:18px;
      padding:14px 22px;border-radius:12px;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.35)
    }
    #bigPlay.hidden{display:none}
    video{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px}
  </style>
</head>
<body>
  <!-- HUD (visible in 2D so you know which build you’re on) -->
  <div id="hud">
    <span class="pill">Build v0.5</span>
    <button id="enterBtn" class="pill">Enter VR</button>
    <span id="status" class="pill">idle</span>
  </div>

  <!-- Big overlay Play/Pause for user gesture -->
  <div id="bigPlay"><button id="bigPlayBtn">Play</button></div>

  <!-- Hidden media element (texture source) -->
  <video id="vid" playsinline muted crossorigin="anonymous"></video>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { VRButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/XRControllerModelFactory.js';

    // ===== CONFIG =====
    const STREAM_URL = 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8'; // swap if needed

    // ===== DOM =====
    const video = document.getElementById('vid');
    const statusEl = document.getElementById('status');
    const bigPlay = document.getElementById('bigPlay');
    const bigPlayBtn = document.getElementById('bigPlayBtn');
    const enterBtn = document.getElementById('enterBtn');

    // ===== HLS attach (only if needed) =====
    async function attachSource(url){
      const isHls = /\.m3u8(\?|$)/i.test(url);
      const native = video.canPlayType('application/vnd.apple.mpegurl') !== '';
      if(isHls && !native){
        await import('https://cdn.jsdelivr.net/npm/hls.js@latest');
        if(window.Hls?.isSupported()){
          const hls = new window.Hls({ maxBufferLength:5, liveBackBufferLength:5 });
          hls.loadSource(url);
          hls.attachMedia(video);
          return;
        }
      }
      video.src = url; // native HLS or MP4
    }

    // ===== THREE / WEBXR =====
    let renderer, scene, camera, plane, videoTex, controller1, controller2;

    initThree();
    setupVideoPlane();
    setupControllers();
    setupXR();
    animate();

    function initThree(){
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
      camera.position.set(0, 1.6, 0);

      scene.add(new THREE.AmbientLight(0xffffff, 0.7));

      window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function setupVideoPlane(){
      // temp geometry; we’ll resize after metadata
      const geom = new THREE.PlaneGeometry(2.8, 1.575);
      const mat = new THREE.MeshBasicMaterial({ color:0xffffff });
      plane = new THREE.Mesh(geom, mat);
      plane.position.set(0, 1.6, -2); // 2m in front
      scene.add(plane);

      videoTex = new THREE.VideoTexture(video);
      videoTex.colorSpace = THREE.SRGBColorSpace;
      videoTex.minFilter = THREE.LinearFilter;
      videoTex.magFilter = THREE.LinearFilter;
      videoTex.generateMipmaps = false;

      // Bind when actually playing
      plane.material.map = null;

      video.addEventListener('loadedmetadata', ()=>{
        const w = video.videoWidth || 16, h = video.videoHeight || 9;
        const aspect = w/Math.max(1,h);
        const width = 2.8;
        const height = width / aspect;
        plane.geometry.dispose();
        plane.geometry = new THREE.PlaneGeometry(width, height);
      });
    }

    function makeRay(){
      const g = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);
      const m = new THREE.LineBasicMaterial({ color:0x44aaff });
      const line = new THREE.Line(g,m);
      line.name = 'ray';
      line.scale.z = 2; // 2m ray
      return line;
    }

    function setupControllers(){
      // Rays
      controller1 = renderer.xr.getController(0);
      controller1.addEventListener('selectstart', onSelect);
      controller1.add(makeRay());
      scene.add(controller1);

      controller2 = renderer.xr.getController(1);
      controller2.addEventListener('selectstart', onSelect);
      controller2.add(makeRay());
      scene.add(controller2);

      // Controller models
      const controllerModelFactory = new XRControllerModelFactory();
      const grip1 = renderer.xr.getControllerGrip(0);
      grip1.add(controllerModelFactory.createControllerModel(grip1));
      scene.add(grip1);

      const grip2 = renderer.xr.getControllerGrip(1);
      grip2.add(controllerModelFactory.createControllerModel(grip2));
      scene.add(grip2);
    }

    // Trigger / A button toggles play/pause
    function onSelect(){
      togglePlay();
    }

    function setupXR(){
      document.body.appendChild(VRButton.createButton(renderer));
      renderer.xr.setSessionInit({
        optionalFeatures:['local-floor','hand-tracking'] // hands if available
      });

      enterBtn.addEventListener('click', async ()=>{
        // Same as clicking VRButton, but keeps a visible control in HUD
        const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures:['local-floor','hand-tracking'] });
        renderer.xr.setSession(session);
      });
    }

    // ===== UI actions =====
    bigPlayBtn.addEventListener('click', startPlayback);

    async function startPlayback(){
      bigPlay.classList.add('hidden');
      status('loading…');
      try{
        await attachSource(STREAM_URL);
        await video.play();
        // Try to unmute after user gesture
        video.muted = false;
        plane.material.map = videoTex;
        plane.material.needsUpdate = true;
        status('playing');
      }catch(e){
        status('playback blocked — click Play again');
        console.error(e);
        bigPlay.classList.remove('hidden');
      }
    }

    function togglePlay(){
      if(video.paused){
        video.play().then(()=>{
          video.muted = false;
          status('playing');
          bigPlay.classList.add('hidden');
        }).catch(err=>{
          status('playback blocked');
          console.error(err);
          bigPlay.classList.remove('hidden');
        });
      }else{
        video.pause();
        status('paused');
        bigPlay.classList.remove('hidden');
        bigPlayBtn.textContent = 'Resume';
      }
    }

    function status(msg){ statusEl.textContent = msg; }

    // ===== Render loop =====
    function animate(){
      renderer.setAnimationLoop(()=>{
        if(plane.material.map === videoTex && !video.paused && !video.ended){
          videoTex.needsUpdate = true;
        }
        renderer.render(scene,camera);
      });
    }
  </script>
</body>
</html>