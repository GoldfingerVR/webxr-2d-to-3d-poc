<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>WebXR 2D→3D POC — v0.12 (strong stereo)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    video{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px}
    canvas{display:block}

    /* HUD (top-left) */
    #hud{position:fixed;z-index:10;left:16px;top:16px;display:flex;gap:8px;align-items:center}
    .pill{background:#303030;color:#e0e0e0;border-radius:999px;padding:6px 10px;font-size:12px;border:1px solid #444;user-select:none}
    .btn-pill{cursor:pointer}
    .btn-pill[aria-disabled="true"]{opacity:.45;cursor:not-allowed}

    /* Overlay gate for autoplay */
    #overlay{
      position:fixed;inset:0;display:flex;flex-direction:column;gap:14px;
      align-items:center;justify-content:center;z-index:12;background:rgba(0,0,0,.55)
    }
    .cta{
      background:#00a86b;border:none;color:#fff;font-weight:700;font-size:18px;
      padding:14px 22px;border-radius:12px;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.35)
    }
    .sub{color:#bbb;font-size:13px}

    /* Bottom status strip (2D) */
    #statusBar{
      position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
      display:flex;gap:8px;align-items:center;z-index:11
    }
    .status-chip{background:#141414;border:1px solid #333;color:#ddd;padding:8px 12px;border-radius:10px;font-size:12px;white-space:nowrap}
    .ok{color:#86f7b1}
    .warn{color:#ffd36e}
    .bad{color:#ff7a7a}

    /* Loader (kept for parity; no model download in this build) */
    #loader{display:none;position:fixed;right:16px;bottom:16px;background:#111;border:1px solid #333;color:#ddd;border-radius:12px;padding:10px 12px;z-index:11;min-width:220px}
    #bar{height:6px;background:#222;border-radius:999px;overflow:hidden;margin-top:8px}
    #fill{height:100%;width:0%;background:#00a86b}
  </style>
</head>
<body>
  <!-- Top HUD -->
  <div id="hud">
    <span class="pill">Build v0.12</span>
    <span id="enterVR" class="pill btn-pill" aria-disabled="true">Enter VR</span>
    <span id="playToggle" class="pill btn-pill" aria-disabled="true">Play</span>
    <span id="status" class="pill">idle</span>
  </div>

  <!-- Autoplay gate -->
  <div id="overlay">
    <button id="playBtn" class="cta">Enable Autoplay</button>
    <div class="sub">Tap to start playback, then use “Enter VR” (top-left).</div>
  </div>

  <!-- Persistent 2D status -->
  <div id="statusBar">
    <span class="status-chip">3D Engine: <strong id="engineState" class="warn">initializing…</strong></span>
    <span class="status-chip">Mode: <strong id="stereoMode">2D (mono)</strong></span>
  </div>

  <!-- (kept for parity) -->
  <div id="loader">
    <div id="loaderText">Preparing…</div>
    <div id="bar"><div id="fill"></div></div>
  </div>

  <!-- Hidden media source -->
  <video id="vid" playsinline muted crossorigin="anonymous"></video>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // -------------------------------------------------
    // Config
    // -------------------------------------------------
    const STREAM_URL = 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4';

    // **Very strong** stereo so the difference is obvious (10× your old 0.035)
    // NOTE: This is intentionally exaggerated for evaluation. Expect eye strain.
    const PARALLAX_M = 0.35; // meters of left/right plane separation

    // -------------------------------------------------
    // DOM
    // -------------------------------------------------
    const video      = document.getElementById('vid');
    const playBtn    = document.getElementById('playBtn');
    const overlay    = document.getElementById('overlay');
    const statusE    = document.getElementById('status');
    const enterVR    = document.getElementById('enterVR');
    const playToggle = document.getElementById('playToggle');

    const engineState= document.getElementById('engineState');
    const stereoMode = document.getElementById('stereoMode');

    // -------------------------------------------------
    // Three / XR state
    // -------------------------------------------------
    let renderer, scene, camera;
    let videoTex, monoPlane = null;
    let stereo = { left:null, right:null };
    let xrSession = null, xrArrayCam = null;

    // 3D engine lifecycle flags (no depth yet; just stereo parallax)
    const engine = { ready:false, active:false };

    // VR status panel (mirrors 2D status)
    let statusPanel = null, statusCanvas = null, statusCtx = null, statusTex = null;

    // -------------------------------------------------
    // Init
    // -------------------------------------------------
    initThree();
    createMonoPlane();
    createStatusPanel();   // VR-readable status under the screen
    animate();
    wireUI();
    probeXR(); // set Enter VR button state

    // -------------------------------------------------
    // UI wiring
    // -------------------------------------------------
    function wireUI(){
      const tryPlay = () => startPlayback().catch(()=>{});
      ['pointerdown','click','touchstart','keydown'].forEach(ev=>{
        overlay.addEventListener(ev, tryPlay, { passive:true });
      });
      playBtn.addEventListener('click', tryPlay);

      playToggle.addEventListener('click', async ()=>{
        if (playToggle.getAttribute('aria-disabled')==='true') return;
        if (video.paused) { await video.play().catch(()=>{}); playToggle.textContent='Pause'; }
        else { video.pause(); playToggle.textContent='Play'; }
      });

      enterVR.addEventListener('click', async ()=>{
        if (enterVR.getAttribute('aria-disabled')==='true') return;
        await startXR();
      });
    }

    // -------------------------------------------------
    // Playback
    // -------------------------------------------------
    async function startPlayback(){
      overlay.style.display = 'none';
      status('loading…');
      try{
        video.src = STREAM_URL;
        video.muted = true;
        video.playsInline = true;
        await video.play();      // needs the tap
        video.muted = false;

        playToggle.textContent = 'Pause';
        playToggle.setAttribute('aria-disabled','false');
        bindVideoTexture();

        // Once we have video, mark engine "ready" (stereo planes available)
        engine.ready = true;
        updateEngineStatus();

        status('playing');
        await probeXR(true);
      }catch(e){
        status('playback blocked');
        overlay.style.display = 'flex';
        console.warn('play() error:', e);
        throw e;
      }
    }

    function bindVideoTexture(){
      if (!videoTex) {
        videoTex = new THREE.VideoTexture(video);
        videoTex.colorSpace = THREE.SRGBColorSpace;
        videoTex.minFilter = THREE.LinearFilter;
        videoTex.magFilter = THREE.LinearFilter;
        videoTex.generateMipmaps = false;
      }
      monoPlane.material.map = videoTex;
      monoPlane.material.needsUpdate = true;

      const applyAspect = () => {
        const w = video.videoWidth || 16, h = video.videoHeight || 9;
        const aspect = w / Math.max(1, h);
        const width = 2.8, height = width / aspect;

        monoPlane.geometry.dispose();
        monoPlane.geometry = new THREE.PlaneGeometry(width, height);

        // Rebuild stereo to match the exact aspect once we enter VR
        if (stereo.left && stereo.right) {
          [stereo.left, stereo.right].forEach(mesh=>{
            mesh.geometry.dispose();
            mesh.geometry = new THREE.PlaneGeometry(width, height);
          });
          positionStereoPlanes(width);
        }

        // Position status panel just below the screen
        if (statusPanel) {
          statusPanel.position.set(0, monoPlane.position.y - (height/2) - 0.15, monoPlane.position.z);
          statusPanel.scale.set(width*0.55, (width*0.55)*0.2, 1);
        }
      };

      if (video.readyState >= 1) applyAspect();
      else video.addEventListener('loadedmetadata', applyAspect, { once:true });
    }

    function createMonoPlane(){
      const geom = new THREE.PlaneGeometry(2.8, 1.575);
      const mat  = new THREE.MeshBasicMaterial({ color:0xffffff });
      monoPlane = new THREE.Mesh(geom, mat);
      monoPlane.position.set(0, 1.6, -2.0);
      scene.add(monoPlane);
    }

    // -------------------------------------------------
    // Stereo (per-eye) output in VR
    // -------------------------------------------------
    function buildStereoPlanes(){
      if (!videoTex) return;

      // Hide mono and create two planes that only render to one eye each
      monoPlane.visible = false;

      const baseGeom = monoPlane.geometry.clone();
      const mkMat = () => new THREE.MeshBasicMaterial({ color:0xffffff, map: videoTex });

      stereo.left  = new THREE.Mesh(baseGeom.clone(), mkMat());
      stereo.right = new THREE.Mesh(baseGeom.clone(), mkMat());

      stereo.left.position.copy(monoPlane.position);
      stereo.right.position.copy(monoPlane.position);

      // Assign object layers (we’ll enable matching layers on the sub-cameras)
      stereo.left.layers.set(1);   // left-eye layer
      stereo.right.layers.set(2);  // right-eye layer

      scene.add(stereo.left);
      scene.add(stereo.right);

      positionStereoPlanes(baseGeom.parameters.width ?? 2.8);

      engine.active = true;
      updateEngineStatus();
    }

    function positionStereoPlanes(width){
      // HUGE separation on purpose so you SEE the difference clearly.
      const shift = PARALLAX_M;
      stereo.left.position.x  = monoPlane.position.x - (shift/2);
      stereo.right.position.x = monoPlane.position.x + (shift/2);

      const pad = 1.01;
      stereo.left.scale.set(pad, pad, 1);
      stereo.right.scale.set(pad, pad, 1);
    }

    // -------------------------------------------------
    // VR status panel (mirrors 2D status)
    // -------------------------------------------------
    function createStatusPanel(){
      statusCanvas = document.createElement('canvas');
      statusCanvas.width = 1024;
      statusCanvas.height = 256;
      statusCtx = statusCanvas.getContext('2d');

      statusTex = new THREE.CanvasTexture(statusCanvas);
      statusTex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.MeshBasicMaterial({ map: statusTex, transparent:true });

      const geom = new THREE.PlaneGeometry(1.2, 0.24);
      statusPanel = new THREE.Mesh(geom, mat);
      statusPanel.position.set(0, 1.1, -2.0);
      scene.add(statusPanel);

      drawStatusPanel();
    }

    function drawStatusPanel(){
      const ctx = statusCtx, W = statusCanvas.width, H = statusCanvas.height;
      ctx.clearRect(0,0,W,H);
      // bg
      ctx.fillStyle = 'rgba(20,20,20,0.85)';
      ctx.fillRect(0,0,W,H);
      ctx.strokeStyle = 'rgba(60,60,60,1)';
      ctx.strokeRect(8,8,W-16,H-16);

      ctx.fillStyle = '#ddd';
      ctx.font = 'bold 44px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillText('3D Engine:', 28, 92);
      ctx.fillText('Mode:', 28, 176);

      const engTxt = engine.active ? 'active (stereo)' : (engine.ready ? 'ready (awaiting VR)' : 'initializing…');
      const engCol = engine.active ? '#86f7b1' : (engine.ready ? '#ffd36e' : '#ffd36e');

      ctx.fillStyle = engCol;
      ctx.fillText(engTxt, 260, 92);

      ctx.fillStyle = '#ddd';
      ctx.fillText((xrSession && engine.active) ? '3D (stereo)' : '2D (mono)', 140, 176);

      statusTex.needsUpdate = true;
    }

    function updateEngineStatus(){
      // 2D chips
      if (!engine.ready) { engineState.textContent='initializing…'; engineState.className='warn'; }
      else if (engine.ready && !engine.active) { engineState.textContent='ready (awaiting VR)'; engineState.className='ok'; }
      else { engineState.textContent='active (stereo)'; engineState.className='ok'; }
      stereoMode.textContent = (xrSession && engine.active) ? '3D (stereo)' : '2D (mono)';

      // VR panel mirror
      drawStatusPanel();
    }

    // -------------------------------------------------
    // WebXR
    // -------------------------------------------------
    async function startXR(){
      if (!navigator.xr) { status('WebXR not available'); return; }
      try{
        xrSession = await navigator.xr.requestSession('immersive-vr', {
          requiredFeatures: ['local-floor'],
          optionalFeatures: ['hand-tracking']
        });
        renderer.xr.setSession(xrSession);
        status('VR started');

        // Grab the array camera and set per-eye layer masks
        xrArrayCam = renderer.xr.getCamera(camera);
        if (xrArrayCam && xrArrayCam.isArrayCamera && xrArrayCam.cameras?.length >= 2) {
          // Left sub-camera renders layer 1; right renders layer 2
          xrArrayCam.cameras[0].layers.enable(1);
          xrArrayCam.cameras[1].layers.enable(2);
        }

        // Switch to stereo when entering VR
        if (engine.ready && !engine.active) buildStereoPlanes();

        xrSession.addEventListener('end', ()=>{
          xrSession = null;
          engine.active = false;
          monoPlane.visible = true;
          if (stereo.left) stereo.left.visible = false;
          if (stereo.right) stereo.right.visible = false;
          status('VR ended');
          updateEngineStatus();
          if (video.paused) {
            video.play().catch(()=>{ overlay.style.display='flex'; });
          }
        });

        updateEngineStatus();
      }catch(e){
        status('VR failed');
        console.warn('requestSession error:', e);
      }
    }

    async function probeXR(){
      const httpsOK = (location.protocol === 'https:') || (location.hostname === 'localhost');
      const xrOK = !!navigator.xr;
      let supported = false;
      try { supported = xrOK ? await navigator.xr.isSessionSupported('immersive-vr') : false; }
      catch(e) { /* ignore */ }
      enterVR.setAttribute('aria-disabled', (httpsOK && supported) ? 'false' : 'true');
    }

    function status(msg){ statusE.textContent = msg; }

    // -------------------------------------------------
    // Three boilerplate
    // -------------------------------------------------
    function initThree(){
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
      camera.position.set(0, 1.6, 0);

      scene.add(new THREE.AmbientLight(0xffffff, 0.7));

      // simple floor so VR isn’t pitch black
      const floor = new THREE.Mesh(
        new THREE.CircleGeometry(3.5, 64),
        new THREE.MeshBasicMaterial({ color:0x101010 })
      );
      floor.rotation.x = -Math.PI/2;
      floor.position.y = 0;
      scene.add(floor);

      window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function animate(){
      renderer.setAnimationLoop(()=>{
        if (videoTex && !video.paused && !video.ended) {
          videoTex.needsUpdate = true;
        }

        // Ensure per-eye layer masks stay applied (some runtimes rebuild cameras)
        if (renderer.xr.isPresenting) {
          const arr = renderer.xr.getCamera(camera);
          if (arr && arr.isArrayCamera && arr.cameras?.length >= 2) {
            arr.cameras[0].layers.enable(1);
            arr.cameras[1].layers.enable(2);
          }
        }

        renderer.render(scene, camera);
      });
    }
  </script>
</body>
</html>